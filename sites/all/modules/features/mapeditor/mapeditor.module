<?php

/**
 * @file
 * Provides functionality for the Mapeditor module.
 */

module_load_include('inc', 'mapeditor', 'mapeditor.formatters');

define('MAPEDITOR_WEBTOOLS_ENVIRONMENT', '//europa.eu/webtools/load.js');

include_once 'mapeditor.features.inc';

/**
 * Implements hook_menu().
 */
function mapeditor_menu() {
  $items['mapeditor/example'] = array(
    'title' => 'Example Page',
    'page callback' => 'example_page',
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'mapeditor.pages.inc',
  );

  $items['mapeditor/example/nuts'] = array(
    'title' => 'NUTS example Page',
    'page callback' => 'example_page_nuts',
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'mapeditor.pages.inc',
  );

  $items['admin/config/system/mapeditor'] = array(
    'title' => 'Mapeditor',
    'description' => 'Configuration for Mapeditor',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer site configuration'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'weight' => '0',
  );

  $items['admin/config/system/mapeditor/settings'] = array(
    'title' => 'Mapeditor settings',
    'description' => 'Settings for Mapeditor',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mapeditor_settings'),
    'access arguments' => array('administer site configuration'),
    'file' => 'mapeditor.forms.inc',
  );

  return $items;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Adds a pop up view mode for each entity.
 * @todo consider theme function instead of view mode.
 */
function mapeditor_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['popup'] = array(
    'label' => t('Pop up'),
    'custom settings' => TRUE,
  );
}

/**
 * Implements hook_form_FORMID_alter().
 *
 * Cleans up the node edit form.
 */
function mapeditor_form_mapeditor_map_node_form_alter(&$form, &$form_state, $form_id) {
  $form['body']['en'][0]['summary']['#access'] = FALSE;
  $form['additional_settings'] = array(
    '#type' => 'vertical_tabs',
    '#weight' => 99,
  );
  $form['body']['#group'] = 'additional_settings';
  $form['body']['#after_build'][] = 'mapeditor_remove_tips';
  $form['#validate'][] = 'mapeditor_validate_zoom';

  // Sets specific field description if there are no mapeditor bundles.
  $config_text = '';
  if (isset($form['mapeditor_geobundle'])) {
    if (count($form['mapeditor_geobundle'][LANGUAGE_NONE]['#options']) < 2) {
      $config_link = l(t('configure content types'), 'admin/config/system/mapeditor/settings');
      $config_text = ' ' . t('If there are no options, then !config_link or contact the site administrator.', array('!config_link' => $config_link));
    }
  }

  // Sets field description.
  $form['mapeditor_geobundle'][LANGUAGE_NONE]['#description'] = t('Select the kind of content that should be included in the map.') . $config_text;
}

/**
 * Removes tips from body field.
 */
function mapeditor_remove_tips(&$form) {
  $form[LANGUAGE_NONE][0]['format']['guidelines']['#access'] = FALSE;
  return $form;
}

/**
 * Provides available content types.
 *
 * Used to populate the content type field in the map node type.
 * @ todo remove
 */
function mapeditor_content_types_map() {
  $content_types = node_type_get_names();
  $content_types_map = variable_get('content_types_map', array());
  if ($content_types_map) {
    foreach ($content_types_map as $key => $ctm) {
      if ($ctm) {
        $content_types_map[$key] = $content_types[$key];
      }
      else {
        unset($content_types_map[$key]);
      }
    }
    return $content_types_map;
  }
  else {
    return array();
  }
}

/**
 * Provides available bundles.
 *
 * Used to provide the geo bundle field with field values in the field.
 */
function mapeditor_geobundles() {
  $geobundles = variable_get('geobundles', array());
  $geobundle_options = array();
  if ($geobundles) {
    foreach ($geobundles as $geobundle) {
      if ($geobundle) {
        $geobundle_shraps = explode('__', $geobundle);

        // Uses combined entity type and bundle name as key in order to
        // be unique.
        $field_info_bundles = field_info_bundles($geobundle_shraps[0]);
        $geobundle_options[$geobundle] = "{$field_info_bundles[$geobundle_shraps[1]]['label']} ({$geobundle_shraps[0]})";
      }
    }
    return $geobundle_options;
  }
  else {
    return array();
  }
}

/**
 * Implements hook_field_extra_fields().
 *
 * Defines the map on the map node type as a pseudo field,
 * allowing it to be displayed, ordered or hidden via the UI.
 */
function mapeditor_field_extra_fields() {
  $extra = array();
  $extra['node']['mapeditor_map']['display']['map'] = array(
    'label' => t('Map'),
    'weight' => 5,
  );
  return $extra;
}

/**
 * Implements hook_entity_view().
 *
 * Defines the content of the map and nuts map pseudo fields.
 */
function mapeditor_node_view($node, $view_mode, $langcode) {
  $extrafields = field_extra_fields_get_display('node', $node->type, $view_mode);

  // Checks if the map field exists and then adds it to the node view.
  if (isset($extrafields['map']) && isset($extrafields['map']['visible']) && $extrafields['map']['visible']) {
    $node->content['map'] = mapeditor_show_map($node);
  }
}

/**
 * Provides the render array that contains the map.
 *
 * The map is a view with custom filters. Based on the content of a map node.
 *
 * @todo improve readability.
 */
function mapeditor_show_map($node) {
  $build = array();

  // Loads map node.
  $wrnode = entity_metadata_wrapper('node', $node);

  // Adds filters for bundle field on the map node.
  $filters = array();
  if (mapeditor_fieldcheck('mapeditor_geobundle', $wrnode)) {

    $geobundle_shraps = explode('__', $wrnode->mapeditor_geobundle->value());

    $filters['entity_type'] = $geobundle_shraps[0];
    $filters['bundle'] = $geobundle_shraps[1];

    // Loads fields and adds filters for each taxo term field on th map node.
    $field_instances = field_info_instances('node', 'mapeditor_map');
    foreach ($field_instances as $field) {
      $field_name = $field['field_name'];

      $field_info = field_info_field($field_name);

      if ($field_info['type'] == 'taxonomy_term_reference' && mapeditor_fieldcheck($field_name, $wrnode)) {
        // @todo verify works with single value fields
        foreach ($wrnode->$field_name->getIterator() as $delta => $term_wrapper) {
          $label = $term_wrapper->name->value();
          $filters['terms'][$field_name][] = $term_wrapper->tid->value();
        }
      }
    }

    // Finds geographical field on geo bundle by comparing geofield setting
    // with instances on bundle. Fetches first found field only.
    $map_field_instances = field_info_instances($geobundle_shraps[0], $geobundle_shraps[1]);
    $geofields = array_map('trim', explode(',', variable_get('geofields')));
    foreach ($geofields as $geofield) {
      if (array_key_exists($geofield, $map_field_instances)) {
        $bundle_geofield = $geofield;
        $filters['bundle_geofield'] = $bundle_geofield;
        break;
      }
    }

    $settings = array(
      'height' => 430,
    );

    // Fetches map settings from map node.
    $map = mapeditor_default_map_settings();

    // Overrides settings if user has provided values in map node.
    if (mapeditor_fieldcheck('mapeditor_initial_zoom', $wrnode) && $wrnode->mapeditor_initial_zoom->value() > 0) {
      // @todo figure out what is bugging initialZoom.
      // $map['settings']['initialZoom'] = $wrnode->initial_zoom->value();
      $map['settings']['zoom'] = $wrnode->mapeditor_initial_zoom->value();
    }
    if (mapeditor_fieldcheck('mapeditor_tile_layer', $wrnode)) {
      $map['settings']['map'] = $wrnode->mapeditor_tile_layer->value();
    }
    if (mapeditor_fieldcheck('mapeditor_max_zoom', $wrnode) && $wrnode->mapeditor_max_zoom->value() > 0) {
      $map['settings']['maxZoom'] = $wrnode->mapeditor_max_zoom->value();
    }
    if (mapeditor_fieldcheck('mapeditor_min_zoom', $wrnode) && $wrnode->mapeditor_min_zoom->value() > 0) {
      $map['settings']['minZoom'] = $wrnode->mapeditor_min_zoom->value();
    }
    if (mapeditor_fieldcheck('mapeditor_height', $wrnode) && $wrnode->mapeditor_height->value() > 0) {
      $map['settings']['height'] = $wrnode->mapeditor_height->value();
    }

    $field = field_info_field($bundle_geofield);

    // Switches between field types (leaflet points or nuts)
    // @todo move large code blocks to separate function for readability.
    switch ($bundle_geofield) {

      case 'nuts_region':
        if (!isset($map['settings']['zoom'])) {
          $map['settings']['zoom'] = 4;
        }

        // Checks if the field type is usable to build a NUTS map.
        if ($field['type'] == 'taxonomy_term_reference') {

          $filters['bundle_geofield_column'] = 'tid';

          $map_items = mapeditor_fetch_entities($filters);
          $nuts = array();
          $nuts_keys = array();
          if ($map_items) {
            foreach ($map_items as $map_item) {
              $wr_map_item = entity_metadata_wrapper($geobundle_shraps[0], $map_item);
              if (mapeditor_fieldcheck('nuts_region', $wr_map_item)) {
                $code = $wr_map_item->nuts_region->nuts_code->value();
                $nuts_keys[] = $wr_map_item->nuts_region->nuts_code->value();
                if (mapeditor_fieldcheck('name', $wr_map_item)) {
                  $nuts[$code]['title'] = $wr_map_item->name->value();
                }
                if (mapeditor_fieldcheck('title', $wr_map_item)) {
                  $nuts[$code]['title'] = $wr_map_item->title->value();
                }
                if (mapeditor_fieldcheck('url', $wr_map_item)) {
                  $nuts[$code]['url'] = $wr_map_item->url->value();
                }
              }
            }

            $nuts = drupal_json_encode($nuts);
            $nuts_keys = drupal_json_encode($nuts_keys);
            $js = "var mapeditor_nuts = ${nuts};
            var mapeditor_nuts_keys = ${nuts_keys};";
            $build['#attached']['js'][] = array(
              'data' => $js,
              'type' => 'inline',
              'scope' => 'footer',
            );
            $build['map'] = mapeditor_build_nuts_map($map, $settings);
          }
          else {
            drupal_set_message('Not enough information to build map.', 'error');
          }
        }
        else {
          drupal_set_message('Can not build a map with this field type.', 'error');
        }
        break;

      // Defaults to geofields.
      default:
        if ($field['type'] == 'geofield') {

          // Generates the leaflet map using lat, lon points
          // Fetches the tiles layer.
          // todo make configurable.
          // @todo: see which parts can be made uniform with field formatter.
          $features = array();
          $all_coordinates = array();

          // Sets the column for the fieldcondition in the EntityFieldQuery.
          // @todo: find a proper way to fix this.
          $filters['bundle_geofield_column'] = 'lat';

          // Fetches the actual content for the map.
          $map_items = mapeditor_fetch_entities($filters);
          if ($map_items) {
            foreach ($map_items as $map_item) {
              $wr_map_item = entity_metadata_wrapper($geobundle_shraps[0], $map_item);

              // Checks if geofield contains points (not other types are
              // possible atm) and populates the geojson feature.
              if (mapeditor_fieldcheck($bundle_geofield, $wr_map_item) && $wr_map_item->$bundle_geofield->geo_type->value() == 'point') {
                // @TODO figure neat way to render popup
                $entity_view = entity_view($geobundle_shraps[0], array($map_item), 'popup');

                // @todo: make configurabe the geofield.
                $features[] = array(
                  'type' => 'Feature',
                  'properties' => array(
                    'name' => $wr_map_item->title->value(),
                    // 'popupContent' => l($wr_map_item->title->value(),
                    // 'node/' . $wr_map_item->nid->value()),
                    // @ todo decide on udage of view mode or theme function.
                    'popupContent' => drupal_render($entity_view),
                  ),
                  'geometry' => array(
                    'type' => mapeditor_geojson_type($wr_map_item->$bundle_geofield->geo_type->value()),
                    'coordinates' => array(
                      // Sets coordinates in GeoJSON standard: X,Y (lon, lat).
                      round($wr_map_item->$bundle_geofield->lon->value(), 4),
                      round($wr_map_item->$bundle_geofield->lat->value(), 4),
                    ),
                  ),
                );
                // Collects all coordinates (lat, lon) for the fitBounds method.
                $all_coordinates[] = array(
                  round($wr_map_item->$bundle_geofield->lat->value(), 4),
                  round($wr_map_item->$bundle_geofield->lon->value(), 4),
                );
              }
            }

            $settings['all_coordinates'] = $all_coordinates;

            // Sets initial map center to first point. Needs to revert
            // lon & lat.
            $map['settings']['center'] = array_reverse($features[0]['geometry']['coordinates']);
            $build['map'] = mapeditor_build_map($map, $features, $settings);
          }
          else {
            drupal_set_message('Not enough information to build map.', 'error');
          }

        }
        else {
          drupal_set_message('Can not build a map with this field type.', 'error');
        }
        break;

    }
  }
  else {
    drupal_set_message('Not enough information to build map.', 'error');
  }
  return $build;
}

/**
 * Inspects wrapped entities & fields.
 */
function mapeditor_wrapper_inspect($w) {
  $values = array();
  foreach ($w->getPropertyInfo() as $key => $val) {
    $values[$key] = $w->$key->value();
  }
  return $values;
}

/**
 * Checks if wrapped entity fields have a value.
 */
function mapeditor_fieldcheck($field, $wrentity) {
  if ($wrentity->__isset($field)) {
    $fieldvalue = $wrentity->$field->value();
    if (!empty($fieldvalue)) {
      return TRUE;
    }
  }
  else {
    return FALSE;
  }
}

/**
 * Fetches entities to be shown on the map.
 *
 * @todo test with users, taxo terms
 */
function mapeditor_fetch_entities($filters) {
  $entities = array();
  $entity_type = $filters['entity_type'];
  $context = og_context();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $filters['bundle'])
    ->fieldCondition($filters['bundle_geofield'], $filters['bundle_geofield_column'], 'NULL', '!=');
  if ($entity_type == 'node') {
    $query->propertyCondition('status', 1);
  }
  
  // Filter map pointers by organic groups.
  if (isset($context['gid'])) {
    $query->fieldCondition('og_group_ref', 'target_id', $context['gid']);
  }

  // Applies taxonomy terms filters;
  if (isset($filters['terms'])) {
    foreach ($filters['terms'] as $term_field => $tids) {
      $query->fieldCondition($term_field, 'tid', $tids, 'in');
    }
  }

  $result = $query->execute();
  if (isset($result[$entity_type])) {
    $eids = array_keys($result[$entity_type]);
    $entities = entity_load($entity_type, $eids);
  }
  return $entities;
}

/**
 * Attaches EC Webtools MAP-required client files and returns render array.
 *
 * Is being used both by map nodes to display multiple nodes with popups and
 * field formatter to show single point.
 */
function mapeditor_build_map($map, $features = array(), $settings = array()) {
  global $base_url;
  $build = array();
  $features = drupal_json_encode($features);

  $load_js = variable_get('webtools_environment', MAPEDITOR_WEBTOOLS_ENVIRONMENT);
  $element = array(
    '#type' => 'markup',
    '#markup' => "<script async src='${load_js}' type='text/javascript'></script>",
  );
  drupal_add_html_head($element, 'async_script');

  // Provides variables for load.js
  $js_path = base_path() . drupal_get_path('module', 'mapeditor') . '/js/map.js?v=' . rand(0, 33333);

  $options = drupal_json_encode(array(
      'service' => 'map',
      'custom' => $js_path,
    )
  );

  $build['load_js_vars'] = array(
    '#type' => 'markup',
    '#markup' => "<script type='application/json'>${options}</script>",
  );

  $js_inline = "var map_height = '{$map['settings']['height']}' + 'px';";

  $build['#attached']['js'][] = array(
    'data' => $js_inline,
    'type' => 'inline',
  );

  $mapeditor_map_settings = drupal_json_encode($map['settings']);

  $js = "var mapeditor_map_settings = {$mapeditor_map_settings};
    var features = {$features};";

  if (isset($settings['all_coordinates'])) {
    $all_coordinates = drupal_json_encode($settings['all_coordinates']);

    $js .= "
      var all_coordinates = {$all_coordinates};
    ";
  }

  $build['#attached']['js'][] = array(
    'data' => $js,
    'type' => 'inline',
    'scope' => 'footer',
  );
  return $build;
}

/**
 * Attaches EC Webtools MAP-required client files and returns render array.
 *
 * Provides custom data for generating a nuts map.
 */
function mapeditor_build_nuts_map($map, $settings = array()) {
  global $base_url;

  $build = array();
  $map_settings = drupal_json_encode($map['settings']);

  $load_js = variable_get('webtools_environment', MAPEDITOR_WEBTOOLS_ENVIRONMENT);
  $element = array(
    '#type' => 'markup',
    '#markup' => "<script async src='${load_js}' type='text/javascript'></script>",
  );
  drupal_add_html_head($element, 'async_script');

  // Provides variables for load.js
  $js_path = base_path() . drupal_get_path('module', 'mapeditor') . '/js/nuts.js?v=' . rand(0, 33333);

  $options = drupal_json_encode(array(
      'service' => 'map',
      'custom' => $js_path,
    )
  );

  $build['load_js_vars'] = array(
    '#type' => 'markup',
    '#markup' => "<script type='application/json'>${options}</script>",
  );

  $js_inline = "var mapeditor_map_settings = {$map_settings};
  var map_height = '{$map['settings']['height']}' + 'px';";

  $build['#attached']['js'][] = array(
    'data' => $js_inline,
    'type' => 'inline',
    'scope' => 'footer',
  );

  return $build;
}

/**
 * Provides zoom options.
 */
function mapeditor_zoom_options() {
  $zoom_options = array(
    -1 => t('Use map defined setting'),
    0 => t('0 - Low/Far'),
    18 => t('18 - High/Close'),
  );
  for ($i = 1; $i < 18; $i++) {
    $zoom_options[$i] = $i;
  }
  ksort($zoom_options);
  return $zoom_options;
}

/**
 * Returns information about fields.
 */
function mapeditor_field_information($entity_type, $bundle) {
  if (module_exists('devel')) {
    $field_instances = field_info_instances("node", "field_inspector");
    foreach ($field_instances as $field_instance) {
      $field = field_info_field($field_instance['field_name']);
    }
  }
  else {
    drupal_set_message('The devel module is needed to display field info.', 'status');
  }
}

/**
 * Validate zoom values.
 */
function mapeditor_validate_zoom($form, &$form_state) {

  $initial_zoom = isset($form_state['values']['initial_zoom'][LANGUAGE_NONE]) ? $form_state['values']['initial_zoom'][LANGUAGE_NONE][0]['value'] : NULL;

  $max_zoom = isset($form_state['values']['max_zoom'][LANGUAGE_NONE]) ? $form_state['values']['max_zoom'][LANGUAGE_NONE][0]['value'] : NULL;

  $min_zoom = isset($form_state['values']['min_zoom'][LANGUAGE_NONE]) ? $form_state['values']['min_zoom'][LANGUAGE_NONE][0]['value'] : NULL;

  if (isset($max_zoom) && $max_zoom != "-1" && isset($min_zoom)) {
    if ($max_zoom > $min_zoom) {
      form_error($element, t('The minimum zoom setting must be less than or equal to the maximum zoom setting'));
    }
  }
}

/**
 * Translates geofield types to geojson types.
 */
function mapeditor_geojson_type($type) {
  switch ($type) {
    case 'point':
      $type = 'Point';
      break;
  }
  return $type;
}

/**
 * Sets feature set api version.
 *
 * @return array
 *   version number
 */
function mapeditor_feature_set_api() {
  return array('version' => '1.0');
}

/**
 * Defines default map settings.
 */
function mapeditor_default_map_settings() {
  return array(
    'settings' => array(
      'center' => array(48, 9),
      'map' => 'osmec',
      'minZoom' => 0,
      'maxZoom' => 18,
      'dragging' => TRUE,
      'touchZoom' => TRUE,
      'scrollWheelZoom' => TRUE,
      'attributionControl' => FALSE,
    ),
  );
}

/**
 * Provides available tiles.
 *
 * Populate the tiles field in the map node type.
 */
function mapeditor_tiles() {
  return array(
    'osmec' => 'Open Street Map customised for European Commission',
    'graybg' => 'Gray background with country outlines',
    'coast' => 'Gray background with continent outlines',
    'gray' => 'Gray shaded relief of earth',
    'hypso' => 'Climate shaded relief of earth',
    'natural' => 'Landcover shaded relief of earth',
    'bmarble' => 'Sattelite  images of earth',
    'copernicus003' => 'Copernicus Core003 mosaic',
  );
}
