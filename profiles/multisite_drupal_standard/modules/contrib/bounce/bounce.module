<?php

/**
 * @file
 * Main module file for the Bounce module.
 */

/*
 -----------------------------------------------------------------------
 Include necessary files.
 -----------------------------------------------------------------------
*/

bounce_include('constant');
bounce_include('user');

/*
 -----------------------------------------------------------------------
 Menu and wildcard loader definitions.
 -----------------------------------------------------------------------
*/

/**
 * Implements hook_menu().
 */
function bounce_menu() {
  $items = array();
  // A list of blocked email addresses, which is also the default local task.
  $items['admin/config/people/bounce'] = array(
    'title' => 'Blocked emails and non-delivery reports',
    'description' => 'Administer blocked email addresses and settings for non-delivery report processing.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bounce_admin_blocked'),
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
  );
  $items['admin/config/people/bounce/blocked'] = array(
    'title' => 'Blocked Mails',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer email non-delivery report processing'),
    'weight' => 1,
  );

  // View non-delivery reports for a particular blocked email address.
  $items['admin/config/people/bounce/blocked/%bounce_blocked_mail'] = array(
    'title' => 'View non-delivery reports',
    'description' => 'View a list of non-delivery reports for a blocked mail.',
    'page callback' => 'bounce_admin_view_blocked_mail',
    'page arguments' => array(5),
    'type' => MENU_VISIBLE_IN_BREADCRUMB,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
  );

  // Callback for the list of all non-delivery reports.
  $items['admin/config/people/bounce/ndr'] = array(
    'title' => 'Non-delivery reports',
    'description' => 'View a list of all non-delivery reports.',
    'page callback' => 'bounce_admin_view_non_delivery_report_list',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
    'weight' => 5,
  );

  // Callback for the data for a particular non-delivery report; the % in there
  // will be 'nojs' or 'ajax'.
  $items['admin/config/people/bounce/ndr/%/%bounce_non_delivery_report'] = array(
    'title' => 'View a non-delivery report',
    'description' => 'View a specific non-delivery report.',
    'page callback' => 'bounce_admin_view_non_delivery_report',
    'page arguments' => array(5, 6),
    'type' => MENU_VISIBLE_IN_BREADCRUMB,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
  );

  // General settings page.
  $items['admin/config/people/bounce/settings'] = array(
    'title' => 'General settings',
    'description' => 'Configure the handling of non-delivery reports generated by bounced emails.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bounce_admin_settings'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
    'weight' => 10,
  );

  // Settings page for the selected mail server connector component.
  $items['admin/config/people/bounce/connector'] = array(
    'title' => 'Connector',
    'description' => 'Administer connector settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'bounce_admin_component_configuration',
      'connector',
      BOUNCE_DEFAULT_CONNECTOR,
    ),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
    'weight' => 15,
  );

  // Settings page for the selected non-delivery report analyst component.
  $items['admin/config/people/bounce/analyst'] = array(
    'title' => 'Analyst',
    'description' => 'Administer non-delivery report analyst settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'bounce_admin_component_configuration',
      'analyst',
      BOUNCE_DEFAULT_ANALYST,
    ),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
    'weight' => 20,
  );

  // Settings page for the selected blocker component.
  $items['admin/config/people/bounce/blocker'] = array(
    'title' => 'Blocker settings',
    'description' => 'Configure mail blocker settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'bounce_admin_component_configuration',
      'blocker',
      BOUNCE_DEFAULT_BLOCKER,
    ),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer email non-delivery report processing'),
    'file' => 'bounce.admin.inc',
    'weight' => 25,
  );

  // The default blocker component adds extra configuration pages in addition
  // to its normal form callback page for component settings above. If a
  // different blocker component is used, then these pages won't be enabled.
  $blocker = variable_get('bounce_blocker', BOUNCE_DEFAULT_BLOCKER);
  if ($blocker == BOUNCE_DEFAULT_BLOCKER) {

    // A list of scores assigned to specific non-delivery codes.
    $items['admin/config/people/bounce/scoring'] = array(
      'title' => 'Blocker scoring',
      'description' => 'Configure scoring of non-delivery reports by code.',
      'page callback' => 'bounce_admin_scoring',
      'type' => MENU_LOCAL_TASK,
      'access arguments' => array('administer email non-delivery report processing'),
      'file' => 'bounce.blocker.inc',
      'weight' => 30,
    );

    // A form to add a new code-score relationship.
    $items['admin/config/people/bounce/scoring/add'] = array(
      'title' => 'Add code',
      'description' => 'Add a new non-delivery report code and scoring.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bounce_admin_edit_code'),
      'type' => MENU_VISIBLE_IN_BREADCRUMB,
      'access arguments' => array('administer email non-delivery report processing'),
      'file' => 'bounce.blocker.inc',
    );

    // A form to edit an existing code-score relationship.
    $items['admin/config/people/bounce/scoring/%bounce_code/edit'] = array(
      'title' => 'Edit code',
      'description' => 'Edit scoring of a non-delivery report code.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bounce_admin_edit_code', 5),
      'type' => MENU_VISIBLE_IN_BREADCRUMB,
      'access arguments' => array('administer email non-delivery report processing'),
      'file' => 'bounce.blocker.inc',
    );

    // A form to delete an existing code-score relationship.
    $items['admin/config/people/bounce/scoring/%bounce_code/delete'] = array(
      'title' => 'Delete code',
      'description' => 'Delete scoring for a non-delivery report code.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bounce_admin_delete_code', 5),
      'type' => MENU_VISIBLE_IN_BREADCRUMB,
      'access arguments' => array('administer email non-delivery report processing'),
      'file' => 'bounce.blocker.inc',
    );
  }
  return $items;
}

/**
 * Autoloader for the %bounce_code wildcard.
 *
 * Returns a row from bounce_code_score.
 *
 * @param string $code
 *   A code machine name.
 *
 * @return array
 *   A associative array for a row from the bounce_code_score
 *   table.
 */
function bounce_code_load($code) {
  return db_select('bounce_code_score', 'cs')
    ->fields('cs', array('code', 'type', 'score', 'description'))
    ->condition('code', $code, '=')
    ->execute()
    ->fetchAssoc();
}

/**
 * Autoloader for the %bounce_blocked_mail wildcard.
 *
 * Returns a row from bounce_blocked.
 *
 * @param string $blocked_id
 *   A primary key for the bounce_blocked table.
 *
 * @return array
 *   A associative array for a row from the bounce_blocked table.
 */
function bounce_blocked_mail_load($blocked_id) {
  return db_select('bounce_blocked', 'b')
    ->fields('b', array('blocked_id', 'mail', 'created'))
    ->condition('blocked_id', $blocked_id, '=')
    ->execute()
    ->fetchAssoc();
}

/**
 * Autoloader for the %bounce_ndr wildcard.
 *
 * Returns a row from bounce_non_delivery_report.
 *
 * @param string $report_id
 *   A primary key for the bounce_non_delivery_report table.
 *
 * @return array
 *   A associative array for a row from the bounce_non_delivery_report table.
 */
function bounce_non_delivery_report_load($report_id) {
  $report = db_select('bounce_non_delivery_report', 'ndr')
    ->fields('ndr')
    ->condition('report_id', $report_id, '=')
    ->execute()
    ->fetchAssoc();
  if ($report) {
    $report['report'] = unserialize($report['report']);
  }
  return $report;
}

/*
 -----------------------------------------------------------------------
 Permissions.
 -----------------------------------------------------------------------
*/

/**
 * Implements hook_permission().
 */
function bounce_permission() {
  return array(
    'administer email non-delivery report processing' => array(
      'title' => t('Administer email non-delivery report processing'),
      'description' => t('Perform administration tasks relating to handling of non-delivery reports generated by bounced emails.'),
    ),
  );
}

/*
 -----------------------------------------------------------------------
 Cron hook implementations and functionality.
 -----------------------------------------------------------------------
*/

/**
 * Implements hook_cron_queue_info().
 *
 * Specify queues for connecting to a mail server and for processing of
 * non-delivery report emails.
 */
function bounce_cron_queue_info() {
  $queues = array();
  // A queue to manage connecting to the mail server to retrieve non-delivery
  // reports.
  $queues['bounce_connection'] = array(
    'worker callback' => 'bounce_process_connection_queue_item',
    'time' => 60,
  );
  // A queue to process non-delivery reports.
  $queues['bounce_non_delivery_report'] = array(
    'worker callback' => 'bounce_process_non_delivery_report_queue_item',
    'time' => 60,
  );
  return $queues;
}

/**
 * Implements hook_cron().
 */
function bounce_cron() {
  // Don't run unless the install is complete; all sorts of mischief can
  // happen.
  if (variable_get('install_task') != 'done') {
    return;
  }

  /*
  ---------------------------------------------
  1) Clear out old data.
  ---------------------------------------------
  */

  bounce_delete_old_data();

  /*
  ---------------------------------------------
  2) Block email addresses where necessary
  ---------------------------------------------
  */

  // Start by obtaining the blocker.
  $blocker = variable_get('bounce_blocker', BOUNCE_DEFAULT_BLOCKER);
  $blockers = bounce_component_definitions('blocker');
  bounce_component_include($blockers[$blocker]);

  // Check to see that the blocker is configured.
  if ($configured = call_user_func($blockers[$blocker]['configured_check_callback'])) {

    // Obtain the list of newly blocked mails.
    $mails = call_user_func($blockers[$blocker]['blocked_callback']);

    // Drop the offending mails into the blocked table if they aren't there
    // already.
    foreach ($mails as $mail) {
      $count = db_select('bounce_blocked')
        ->condition('mail', $mail, '=')
        ->countQuery()
        ->execute()
        ->fetchField();
      if (!$count) {
        // Write the record.
        $record = array(
          'mail' => $mail,
          'created' => time(),
        );
        drupal_write_record('bounce_blocked', $record);
        // And flag the non-delivery reports for this mail as being used.
        db_update('bounce_non_delivery_report')
          ->fields(array(
            'status' => BOUNCE_NDR_STATUS_USED,
          ))
          ->condition('mail', $mail, '=')
          ->execute();
        // And log.
        watchdog('bounce', 'Outgoing mail to %mail is now blocked.', array('%mail' => $mail), WATCHDOG_INFO);
      }
    }
    // Call the hook if there were any mails to block.
    if ($mails) {
      module_invoke_all('bounce_mails_blocked', $mails);
    }
  }

  /*
  ----------------------------------------------
  3) Add a queue item to connect to the mail server
  ----------------------------------------------
  */

  $queue = DrupalQueue::get('bounce_connection');
  $queue->createItem(array());
}

/**
 * Remove old records of sent mail and non-delivery reports.
 */
function bounce_delete_old_data() {
  // Delete old sent mail records - very straightforward.
  $age_in_seconds = variable_get('bounce_max_sent_age_days', BOUNCE_DEFAULT_MAX_SENT_AGE_DAYS) * 86400;
  $time = time() - $age_in_seconds;
  db_delete('bounce_sent')
    ->condition('created', $time, '<')
    ->execute();

  // Delete old non-delivery reports. This is a little more complex. We want to
  // keep non-delivery reports that were used to block an email address, but
  // only if the email address is still blocked.
  $age_in_seconds = variable_get('bounce_max_report_age_days', BOUNCE_DEFAULT_MAX_REPORT_AGE_DAYS) * 86400;
  $time = time() - $age_in_seconds;
  db_delete('bounce_non_delivery_report')
    ->condition('created', $time, '<')
    ->where('status = :status OR NOT EXISTS (SELECT 1 FROM {bounce_blocked} b WHERE b.mail = {bounce_non_delivery_report}.mail)', array(':status' => BOUNCE_NDR_STATUS_UNUSED))
    ->execute();
}

/**
 * Cron queue callback.
 *
 * Connect to a mail server account and retrieve the non-delivery report
 * emails therein. Add the emails to the non-delivery report processing
 * queue, and delete them from the server.
 */
function bounce_process_connection_queue_item($item) {
  // Obtain the connector.
  $connector = variable_get('bounce_connector', BOUNCE_DEFAULT_CONNECTOR);
  $connectors = bounce_component_definitions('connector');
  bounce_component_include($connectors[$connector]);

  // Check to see that the connector is configured.
  if (call_user_func($connectors[$connector]['configured_check_callback']) != TRUE) {
    return;
  }

  // Obtain a set of non-delivery report emails from the mail server via
  // the connector.
  $reports = call_user_func($connectors[$connector]['reports_callback']);

  // Add the non-delivery reports to the queue for processing, if we have any.
  if ($reports && is_array($reports)) {
    watchdog(
      'bounce',
      'Retrieved @reports from the Return-Path account.',
      array(
        '@reports' => format_plural(count($reports), '1 potential non-delivery report', '@count potential non-delivery reports'),
      ),
      WATCHDOG_INFO
    );
    $queue = DrupalQueue::get('bounce_non_delivery_report');
    foreach ($reports as $report) {
      $queue->createItem($report);
    }
    // Add another connection to the server to the queue, since we limit
    // how many reports are taken from the server in a single connection.
    // There may still be more non-delivery report emails in the account.
    $queue = DrupalQueue::get('bounce_connection');
    $queue->createItem(array());
  }
}

/**
 * Cron queue callback. Process a single non-delivery report email.
 *
 * The $report parameter must be an indexed array of message parts, each of
 * which is a subarray with at least 'charset' and 'data' keys.
 *
 * $report = array(
 *  [0] => array(
 *    ['data'] => string
 *    ['charset'] => the encoding of the string
 *  ),
 *  [1] => ...
 * )
 *
 * The message parts should be in the order they occurred in the email, and not
 * include the non-delivery report mail headers.
 *
 * @param array $report
 *   The non-delivery report email data.
 */
function bounce_process_non_delivery_report_queue_item($report) {
  // Obtain the connector.
  $analyst = variable_get('bounce_analyst', BOUNCE_DEFAULT_ANALYST);
  $analysts = bounce_component_definitions('analyst');
  bounce_component_include($analysts[$analyst]);

  // Check to see that the analyst is configured.
  if (call_user_func($analysts[$analyst]['configured_check_callback']) != TRUE) {
    return;
  }

  // Pass in the report and obtain an analysis in return.
  $analysis = call_user_func($analysts[$analyst]['analysis_callback'], $report);

  // Run it through hook alter.
  drupal_alter('bounce_analysis', $analysis, $report);
  // Record the result if it merits recording.
  bounce_include('analysis');

  if ($complete = bounce_is_complete_non_delivery_report_analysis($analysis)) {
    bounce_record_non_delivery_report_analysis($analysis, $analyst, $report);
  }
}

/*
 -----------------------------------------------------------------------
 Sundry helper functions.
 -----------------------------------------------------------------------
*/

/**
 * Loads an include file in the include folder for this module.
 *
 * @param string $include
 *   The identifier for the file.
 */
function bounce_include($include) {
  require_once dirname(__FILE__) . '/bounce.' . $include . '.inc';
}

/**
 * Helper function to return a list of component definitions.
 *
 * @param string $type
 *   The component type, i.e. 'blocker', 'connector', 'analyst'.
 *
 * @return array
 *   An associative array of component definitions.
 */
function bounce_component_definitions($type) {
  $components = &drupal_static(__FUNCTION__ . $type);
  if (!isset($components)) {
    $components = array();
    $modules = module_implements('bounce_' . $type);
    foreach ($modules as $module) {
      $defined = module_invoke($module, 'bounce_' . $type);
      foreach ($defined as $name => $definition) {
        $components[$name] = $definition;
        $components[$name]['module'] = $module;
      }
    }
    drupal_alter('bounce_' . $type, $components);
    $check_function = 'bounce_is_valid_' . $type;
    foreach ($components as $name => $definition) {
      if (!call_user_func($check_function, $definition)) {
        unset($components[$name]);
      }
    }
  }
  return $components;
}

/**
 * Validate a blocker component definition.
 *
 * @param array $blocker
 *   A blocker definition
 *
 * @return bool
 *   TRUE if valid, FALSE if not.
 */
function bounce_is_valid_blocker($blocker) {
  $blocker += array(
    'title' => '',
    'blocked_callback' => '',
    'settings_callback' => '',
    'configured_check_callback' => '',
    'file' => NULL,
    'module' => 'bounce',
  );
  if (!$blocker['title'] || !$blocker['blocked_callback'] || !$blocker['settings_callback'] || !$blocker['configured_check_callback']) {
    return FALSE;
  }
  bounce_component_include($blocker);
  if (!function_exists($blocker['blocked_callback']) || !function_exists($blocker['settings_callback']) || !function_exists($blocker['configured_check_callback'])) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Validate an analyst component definition.
 *
 * @param array $analyst
 *   An analyst definition.
 *
 * @return bool
 *   TRUE if valid, FALSE if not.
 */
function bounce_is_valid_analyst($analyst) {
  $analyst += array(
    'title' => '',
    'analysis_callback' => '',
    'settings_callback' => '',
    'configured_check_callback' => '',
    'file' => NULL,
    'module' => 'bounce',
  );
  if (!$analyst['title'] || !$analyst['analysis_callback'] || !$analyst['settings_callback'] || !$analyst['configured_check_callback']) {
    return FALSE;
  }
  bounce_component_include($analyst);
  if (!function_exists($analyst['analysis_callback']) || !function_exists($analyst['settings_callback']) || !function_exists($analyst['configured_check_callback'])) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Validate a mailserver connector definition.
 *
 * @param array $connector
 *   A connector definition.
 *
 * @return bool
 *   TRUE if valid, FALSE if not.
 */
function bounce_is_valid_connector($connector) {
  $connector += array(
    'title' => '',
    'reports_callback' => '',
    'settings_callback' => '',
    'configured_check_callback' => '',
    'file' => NULL,
    'module' => 'bounce',
  );
  if (!$connector['title'] || !$connector['reports_callback'] || !$connector['settings_callback'] || !$connector['configured_check_callback']) {
    return FALSE;
  }
  bounce_component_include($connector);
  if (!function_exists($connector['reports_callback']) || !function_exists($connector['settings_callback']) || !function_exists($connector['configured_check_callback'])) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Load an include file for a component defined via a hook.
 *
 * The component has both a 'file' key and 'module' key in its definition
 * array. Use these to load the specified file.
 *
 * @param array $component
 *   A component definition.
 */
function bounce_component_include($component) {
  if (isset($component['file']) && $component['file'] && isset($component['module']) && $component['module']) {
    $file = './' . drupal_get_path('module', $component['module']) . '/' . $component['file'];
    if (is_file($file)) {
      require_once $file;
    }
  }
}

/**
 * Helper function to parse out distinct emails from text.
 *
 * @param string $text
 *   A string that may contain emails.
 *
 * @return array
 *   An array listing the distinct emails matched, with no duplicates.
 */
function bounce_unique_mails_from_text($text) {
  return array_values(array_unique(bounce_mails_from_text($text)));
}

/**
 * Helper function to parse out emails from text.
 *
 * @param string $text
 *   A string that may contain emails.
 *
 * @return array
 *   An array of all the emails matched, which may include duplicates.
 */
function bounce_mails_from_text($text) {
  $matches = array();
  // See here for a discussion of this email-matching regex:
  // http://www.exratione.com/2012/09/what-constitutes-an-acceptable-email-regex/
  //
  // This will match some things that look like email addresses but are not
  // email addresses, but that should not be a problem in practice.
  preg_match_all('/([^\p{Z}<]+@[\p{L}\p{M}\p{N}.-]+\.(\p{L}\p{M}*){2,6})(>|\p{Z}|$)/ui', $text, $matches);
  $mails = $matches[1];
  foreach ($mails as $index => $mail) {
    if (!valid_email_address($mail)) {
      unset($mails[$index]);
    }
  }
  return $mails;
}

/**
 * Generate a UUID.
 *
 * This is taken from the following suggested implementation:
 * http://www.php.net/manual/en/function.uniqid.php#94959
 *
 * @return string
 *   A UUID.
 */
function _bounce_generate_uuid() {
  $uuid = sprintf('%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
    // 32 bits for "time_low".
    mt_rand(0, 0xffff), mt_rand(0, 0xffff),
    // 16 bits for "time_mid".
    mt_rand(0, 0xffff),
    // 16 bits for "time_hi_and_version", four most significant bits holds
    // version number 4.
    mt_rand(0, 0x0fff) | 0x4000,
    // 16 bits, 8 bits for "clk_seq_hi_res", 8 bits for "clk_seq_low",
    // two most significant bits holds zero and one for variant DCE1.1.
    mt_rand(0, 0x3fff) | 0x8000,
    // 48 bits for "node".
    mt_rand(0, 0xffff), mt_rand(0, 0xffff), mt_rand(0, 0xffff)
  );
  // Trivial replacements to avoid rare issues with parsing responses for SMTP
  // response codes.
  $uuid = str_replace('4', '!', $uuid);
  $uuid = str_replace('5', '?', $uuid);
  return $uuid;
}

/**
 * Given an RFC 2822 set of addresses, remove those that are blocked.
 *
 * This isn't fully compliant with RFC2822 - it doesn't deal with groups, for
 * example, but then we don't expect to have to in this environment.
 *
 * @param string $to
 *   The RFC 2822 set of emails to send to.
 *
 * @return string
 *   The amended RFC 2822 addresses string.
 */
function bounce_mail_remove_blocked_addresses($to) {
  $addresses = explode(',', $to);
  // Did some non-compliant code pass us an empty string or a null or some
  // other not so useful value?
  if (empty($addresses)) {
    return '';
  }
  // Otherwise, onward.
  $blocked_addresses = bounce_determine_blocked_addresses($addresses);
  return implode(',', array_diff($addresses, $blocked_addresses));
}

/**
 * Determine which of the provided email addresses are blocked by Bounce.
 * This works for plain email addresses or RFC 2822 formatted email
 * addresses. e.g. "me@example.com", "Me <me@example.com>", etc.
 *
 * @param array $addresses
 *   An array of RFC 2822 email addresses.
 *
 * @return array
 *   An array containing the email addresses that are blocked by Bounce.
 *   The emails will be returned in the same format that they were
 *   supplied.
 */
function bounce_determine_blocked_addresses($addresses) {
  // If passed something useless, such as NULL or an empty array, then skip
  // and return an empty array.
  if (!is_array($addresses) || empty($addresses)) {
    return array();
  }

  // Otherwise, onward.
  $destinations = array();
  foreach ($addresses as $address) {
    $emails = bounce_unique_mails_from_text($address);
    if ($emails) {
      $destinations[array_shift($emails)] = $address;
    }
  }

  // It's quite possible for an array of alleged addresses passed in from
  // third party code to have nothing in it that's recognizable as an email
  // address. So $destinations might be empty. If so, return.
  if (empty($destinations)) {
    return array();
  }

  $blocked_mails = db_select('bounce_blocked', 'b')
    ->fields('b', array('mail'))
    ->condition('b.mail', array_keys($destinations), 'IN')
    ->execute()
    ->fetchCol();
  $blocked_destinations = array_intersect_key($destinations, array_flip($blocked_mails));
  return array_values($blocked_destinations);
}

/*
 -----------------------------------------------------------------------
 Miscellaneous hook implementations.
 -----------------------------------------------------------------------
*/

/**
 * Implements hook_mail_alter().
 *
 * Here we do the following:
 *
 * 1) Set the return path header to the address specified in the admin settings
 * form.
 *
 * 2) Add an identifier to the headers that should help match up non-delivery
 * reports with the email address that the originating mail was sent to.
 *
 * 3) Block outgoing mail to by removing addresses from $message['to'] or
 * setting $message['send'] = FALSE.
 */
function bounce_mail_alter(&$message) {
  $return_path = variable_get('bounce_mail_header_return_path', '');
  if ($return_path) {
    $message['headers']['Return-Path'] = $return_path;
  }

  // Alter the "to" string to remove mails that are blocked. Remember that this
  // is RFC 2822, so could be a comma-delimited string of multiple addresses.
  $to = bounce_mail_remove_blocked_addresses($message['to']);
  if (empty($to)) {
    // No non-blocked addresses to send to, so don't send it.
    $message['send'] = FALSE;
    return;
  }
  else {
    // Update and carry on.
    $message['to'] = $to;
  }

  // If there is more than one email then they all get the same header.
  // That makes it more of a pain to figure out which one generated a
  // non-delivery report later on, but oh well.
  $header_id_key = variable_get('bounce_mail_header_name', BOUNCE_DEFAULT_MAIL_HEADER_NAME);
  $header_id_value = _bounce_generate_uuid();
  $message['headers'][$header_id_key] = $header_id_value;

  // Write one or more records of the sent mail, so that a non-delivery report
  // can later be matched.
  $mail_data = array();
  $mail_data[] = array(
    'mail' => $to,
    'header_id' => $header_id_value,
  );
  bounce_record_sent_mails($mail_data);
}

/**
 * Record a set of sent mails.
 *
 * The provided data includes the email address and unique header ID for each
 * sent mail, so that they can be identified later if a non-delivery report
 * shows up.
 *
 * array(
 *   'mail' => $email,
 *   'header_id' => $header_id_value,
 * );
 *
 * @param array $mail_data
 *   An array of arrays, each subarray provided an email address and unique
 *   header ID for a single outgoing mail.
 *
 */
function bounce_record_sent_mails($mail_data) {
  // Some of the addresses may be to multiple recipients, in which case they
  // have to be split out, and gain a record each. If there is more than one
  // email then they all get the same header ID. That makes it more of a pain
  // to figure out which one generated a non-delivery report later on, but oh
  // well.
  $extra_mail_data = array();
  $time = time();
  foreach ($mail_data as &$mail) {
    $mail['created'] = $time;
    $emails = bounce_unique_mails_from_text($mail['mail']);
    // Put the first raw address back in to this array.
    $mail['mail'] = array_shift($emails);
    // And then stack any others into the extra array, which we will merge
    // in at the end.
    foreach ($emails as $email) {
      $extra_mail_data[] = array(
        'created' => $time,
        'mail' => $email,
        'header_id' => $mail['header_id'],
      );
    }
  }

  $mail_data = array_merge($mail_data, $extra_mail_data);

  $query = db_insert('bounce_sent')
    ->fields(array('mail', 'header_id', 'created'));
  foreach ($mail_data as $mail) {
    // Probably not a necessary check, but better safe than sorry.
    if ($mail['mail']) {
      $query->values($mail);
    }
  }
  $query->execute();
}


/*
 -----------------------------------------------------------------------
 Implementations of bounce module hooks.

 These define the default set of code types and components: connector,
 blocker, and analyst.
 -----------------------------------------------------------------------
*/

/**
 * Implements hook_bounce_code_type().
 */
function bounce_bounce_code_type() {
  $types = array();
  $types['rfc821'] = array(
    'title' => t('RFC 821'),
    'description' => t('SMTP response codes from RFC 821.'),
  );
  $types['rfc1893'] = array(
    'title' => t('RFC 1893'),
    'description' => t('SMTP response codes from RFC 1893.'),
  );
  $types['rfc5965'] = array(
    'title' => t('RFC 5965'),
    'description' => t('Response codes relating to Abuse Reporting Format notices from RFC 1893.'),
  );
  $types['system'] = array(
    'title' => t('System'),
    'description' => t('Response codes assigned by the Bounce module.'),
  );
  $types['custom'] = array(
    'title' => t('Custom'),
    'description' => t('Custom codes added by admins or other modules.'),
  );
  return $types;
}

/**
 * Implements hook_bounce_analyst().
 */
function bounce_bounce_analyst() {
  $analysts = array();
  $analysts['default'] = array(
    'title' => t('Default: simple mail header and body parser'),
    'analysis_callback' => 'bounce_analyze_non_delivery_report',
    'settings_callback' => 'bounce_analyst_settings',
    'configured_check_callback' => 'bounce_analyst_is_configured',
    'file' => 'bounce.analysis.inc',
  );
  return $analysts;
}

/**
 * Implements hook_bounce_connector().
 */
function bounce_bounce_connector() {
  $connectors = array();
  $connectors['default'] = array(
    'title' => t('Default: POP3 or IMAP'),
    'reports_callback' => 'bounce_connect',
    'settings_callback' => 'bounce_connect_settings',
    'configured_check_callback' => 'bounce_connector_is_configured',
    'file' => 'bounce.connector.inc',
  );
  return $connectors;
}

/**
 * Implements hook_bounce_blocker().
 */
function bounce_bounce_blocker() {
  $blockers = array();
  $blockers['default'] = array(
    'title' => t('Default: block by threshold score'),
    'blocked_callback' => 'bounce_blocked',
    'settings_callback' => 'bounce_blocker_settings',
    'configured_check_callback' => 'bounce_blocker_is_configured',
    'file' => 'bounce.blocker.inc',
  );
  return $blockers;
}
